-- Package Scripts Parser Utility\n--\n-- This module provides comprehensive parsing and categorization of npm scripts from\n-- package.json files with advanced filtering, intelligent categorization, and rich metadata.\n-- Adapted for script-runner.nvim plugin.\n--\n-- Features:\n--   ‚Ä¢ Automatic script categorization (build, test, lint, deploy, etc.)\n--   ‚Ä¢ Advanced filtering (lifecycle, debug, patterns, categories)\n--   ‚Ä¢ Rich metadata with icons and flags\n--   ‚Ä¢ Parent directory traversal for package.json discovery\n--   ‚Ä¢ Comprehensive error handling\n--\n-- Usage:\n--   local pkg_scripts = require('script-runner.utils.package-scripts')\n--   local scripts, err = pkg_scripts.get_package_scripts()\n--   if scripts then\n--     for _, script in ipairs(scripts) do\n--       print(script.icon .. " " .. script.name .. ": " .. script.command)\n--     end\n--   end\n--\n-- Integration with other modules:\n--   local package_manager = require('script-runner.utils.package-manager')\n--   local manager = package_manager.detect_package_manager()\n--   -- Use detected manager to run selected scripts\n--\n-- Available categories:\n--   start, test, build, lint, format, deploy, clean, watch, docs, install, debug, lifecycle, unknown\n---@class PackageScripts\nlocal M = {}\n\nlocal uv = vim.loop\n\n---@class FilterOptions\n---@field exclude_lifecycle? boolean Exclude npm lifecycle scripts (default: true)\n---@field exclude_debug? boolean Exclude debug-only scripts (default: false)\n---@field include_patterns? string[] Include scripts matching these patterns\n---@field exclude_patterns? string[] Exclude scripts matching these patterns\n---@field categories? string[] Only include scripts from these categories\n\n---@class PackageScript\n---@field name string Script name\n---@field command string Script command\n---@field category string Script category (start, test, build, etc.)\n---@field is_lifecycle boolean Whether this is an npm lifecycle script\n---@field is_debug boolean Whether this appears to be a debug script\n---@field icon string Icon for UI display\n\n-- Default filter options\nlocal DEFAULT_FILTER_OPTIONS = {\n  exclude_lifecycle = true,\n  exclude_debug = false,\n  include_patterns = {},\n  exclude_patterns = {},\n  categories = {}\n}\n\n-- NPM lifecycle scripts that are automatically run\n-- Only including actual npm lifecycle scripts, not custom pre/post hooks\nlocal LIFECYCLE_SCRIPTS = {\n  'preinstall', 'install', 'postinstall',\n  'preuninstall', 'uninstall', 'postuninstall',\n  'preversion', 'version', 'postversion',\n  'prepublish', 'prepare', 'prepublishOnly', 'publish', 'postpublish'\n}\n\n-- Script category patterns\nlocal CATEGORY_PATTERNS = {\n  start = { '^start', '^serve', '^dev' },\n  test = { '^test', '^spec', '^jest', '^mocha', '^vitest' },\n  build = { '^build', '^compile', '^bundle', '^dist' },\n  lint = { '^lint', '^eslint', '^tslint', '^prettier' },\n  format = { '^format', '^fmt', '^prettier' },\n  deploy = { '^deploy', '^publish', '^release' },\n  clean = { '^clean', '^clear', '^reset' },\n  watch = { '^watch', '^dev' },\n  docs = { '^docs', '^doc', '^generate%-docs' },\n  install = { '^install', '^setup', '^bootstrap' },\n  -- Additional patterns for common script types\n  check = { '^check' },\n  fix = { '^fix' },\n  generate = { '^generate' },\n  docker = { 'docker', ':docker$' },\n  nuke = { 'nuke' }\n}\n\n-- Debug script patterns\nlocal DEBUG_PATTERNS = {\n  'debug', 'inspect', 'node%-inspect', '%-%-debug', '%-%-inspect',\n  -- Additional patterns for bun/node debugging\n  'bun %-%-inspect', 'node %-%-inspect', '%-inspect',\n  -- Case-insensitive patterns\n  'DEBUG', 'INSPECT'\n}\n\n-- Icon mapping for different script categories\nlocal SCRIPT_ICONS = {\n  start = 'üéÜ', -- More fun than play button\n  test = 'üß™',\n  build = 'üî®',\n  lint = 'üîç',\n  format = '‚ú®',\n  deploy = 'üöÄ',\n  clean = 'üßπ',\n  watch = 'üëÄ',\n  docs = 'üìö',\n  install = 'üì¶',\n  debug = 'üêõ',\n  lifecycle = '‚öôÔ∏è',\n  check = '‚úÖ',\n  fix = 'üîß',\n  generate = '‚ö°',\n  docker = 'üê≥',\n  nuke = '‚ò¢Ô∏è', -- Radioactive symbol for destructive operations\n  unknown = 'üìÑ'\n}\n\n---Check if a script name matches any pattern in a list\n---@param script_name string\n---@param patterns string[]\n---@return boolean\nlocal function matches_patterns(script_name, patterns)\n  for _, pattern in ipairs(patterns) do\n    if script_name:match(pattern) then\n      return true\n    end\n  end\n  return false\nend\n\n---Check if a script is a lifecycle script\n---@param script_name string\n---@return boolean\nlocal function is_lifecycle_script(script_name)\n  -- Check exact matches for known lifecycle scripts\n  for _, lifecycle in ipairs(LIFECYCLE_SCRIPTS) do\n    if script_name == lifecycle then\n      return true\n    end\n  end\n  \n  -- Check for pre/post hooks (any script starting with \"pre\" or \"post\")\n  -- These are automatically run by npm and should not be run explicitly\n  if script_name:match('^pre[a-zA-Z]') or script_name:match('^post[a-zA-Z]') then\n    return true\n  end\n  \n  return false\nend\n\n---Check if a script appears to be debug-related\n---@param script_name string\n---@param script_command string\n---@return boolean\nlocal function is_debug_script(script_name, script_command)\n  -- Check for start and test scripts - these are commonly debugged in development\n  if script_name:match('^start:') or script_name:match('^test:') then\n    return true\n  end\n  \n  -- Check script name for debug keywords\n  for _, pattern in ipairs(DEBUG_PATTERNS) do\n    if script_name:match(pattern) then\n      return true\n    end\n  end\n  \n  -- Check script command for debug flags\n  for _, pattern in ipairs(DEBUG_PATTERNS) do\n    if script_command:match(pattern) then\n      return true\n    end\n  end\n  \n  return false\nend\n\n---Categorize a script based on its name and command\n---@param script_name string\n---@param script_command string\n---@return string\nlocal function categorize_script(script_name, script_command)\n  -- Check for lifecycle scripts first (these should never be run manually)\n  if is_lifecycle_script(script_name) then\n    return 'lifecycle'\n  end\n  \n  -- Check category patterns to show what the script actually does\n  for category, patterns in pairs(CATEGORY_PATTERNS) do\n    if matches_patterns(script_name, patterns) then\n      return category\n    end\n  end\n  \n  return 'unknown'\nend\n\n---Get icon for a script category\n---@param category string\n---@return string\nfunction M.get_script_icon(category)\n  return SCRIPT_ICONS[category] or SCRIPT_ICONS.unknown\nend\n\n---Get all available script categories\n---@return string[]\nfunction M.get_categories()\n  local categories = {}\n  for category, _ in pairs(CATEGORY_PATTERNS) do\n    table.insert(categories, category)\n  end\n  table.insert(categories, 'debug')\n  table.insert(categories, 'lifecycle')\n  table.insert(categories, 'unknown')\n  return categories\nend\n\n---Parse package.json and extract scripts\n---@param package_path string Path to package.json file\n---@return table<string, string>|nil scripts, string|nil error\nlocal function parse_package_json(package_path)\n  local file = io.open(package_path, 'r')\n  if not file then\n    return nil, 'Could not open package.json at ' .. package_path\n  end\n  \n  local content = file:read('*all')\n  file:close()\n  \n  local success, package_data = pcall(vim.fn.json_decode, content)\n  if not success then\n    return nil, 'Invalid JSON in package.json'\n  end\n  \n  if not package_data.scripts or type(package_data.scripts) ~= 'table' then\n    return {}, nil\n  end\n  \n  return package_data.scripts, nil\nend\n\n---Apply filters to scripts\n---@param scripts PackageScript[]\n---@param filter_options FilterOptions\n---@return PackageScript[]\nlocal function apply_filters(scripts, filter_options)\n  local filtered = {}\n  \n  for _, script in ipairs(scripts) do\n    local should_include = true\n    \n    -- Filter by lifecycle scripts\n    if filter_options.exclude_lifecycle and script.is_lifecycle then\n      should_include = false\n    end\n    \n    -- Filter by debug scripts\n    if filter_options.exclude_debug and script.is_debug then\n      should_include = false\n    end\n    \n    -- Filter by include patterns\n    if #filter_options.include_patterns > 0 then\n      if not matches_patterns(script.name, filter_options.include_patterns) then\n        should_include = false\n      end\n    end\n    \n    -- Filter by exclude patterns\n    if #filter_options.exclude_patterns > 0 then\n      if matches_patterns(script.name, filter_options.exclude_patterns) then\n        should_include = false\n      end\n    end\n    \n    -- Filter by categories\n    if #filter_options.categories > 0 then\n      local category_match = false\n      for _, category in ipairs(filter_options.categories) do\n        if script.category == category then\n          category_match = true\n          break\n        end\n      end\n      if not category_match then\n        should_include = false\n      end\n    end\n    \n    if should_include then\n      table.insert(filtered, script)\n    end\n  end\n  \n  return filtered\nend\n\n---Find package.json file starting from cwd and walking up\n---@param cwd string Starting directory\n---@return string|nil package_json_path, string|nil error\nlocal function find_package_json(cwd)\n  local current_path = vim.fn.fnamemodify(cwd, ':p:h') -- Get absolute path\n  \n  while current_path ~= '/' and current_path ~= '' do\n    local package_path = current_path .. '/package.json'\n    local stat = uv.fs_stat(package_path)\n    \n    if stat and stat.type == 'file' then\n      return package_path, nil\n    end\n    \n    -- Move up one directory\n    local parent = vim.fn.fnamemodify(current_path, ':h')\n    if parent == current_path then\n      break -- Reached root\n    end\n    current_path = parent\n  end\n  \n  return nil, 'No package.json found in ' .. cwd .. ' or parent directories'\nend\n\n---Get package.json scripts with filtering and categorization\n---@param cwd string|nil Current working directory (defaults to vim.fn.getcwd())\n---@param filter_options FilterOptions|nil Filter options (optional)\n---@return PackageScript[]|nil scripts, string|nil error\nfunction M.get_package_scripts(cwd, filter_options)\n  cwd = cwd or vim.fn.getcwd()\n  filter_options = vim.tbl_deep_extend('force', DEFAULT_FILTER_OPTIONS, filter_options or {})\n  \n  -- Find package.json\n  local package_path, find_error = find_package_json(cwd)\n  if not package_path then\n    return nil, find_error\n  end\n  \n  -- Parse package.json\n  local raw_scripts, parse_error = parse_package_json(package_path)\n  if not raw_scripts then\n    return nil, parse_error\n  end\n  \n  -- Convert to PackageScript objects\n  local scripts = {}\n  for name, command in pairs(raw_scripts) do\n    local category = categorize_script(name, command)\n    local script = {\n      name = name,\n      command = command,\n      category = category,\n      is_lifecycle = is_lifecycle_script(name),\n      is_debug = is_debug_script(name, command),\n      icon = M.get_script_icon(category)\n    }\n    table.insert(scripts, script)\n  end\n  \n  -- Sort scripts alphabetically\n  table.sort(scripts, function(a, b)\n    return a.name < b.name\n  end)\n  \n  -- Apply filters\n  local filtered_scripts = apply_filters(scripts, filter_options)\n  \n  return filtered_scripts, nil\nend\n\n---Get scripts grouped by category\n---@param cwd string|nil Current working directory\n---@param filter_options FilterOptions|nil Filter options\n---@return table<string, PackageScript[]>|nil grouped_scripts, string|nil error\nfunction M.get_scripts_by_category(cwd, filter_options)\n  local scripts, error = M.get_package_scripts(cwd, filter_options)\n  if not scripts then\n    return nil, error\n  end\n  \n  local grouped = {}\n  for _, script in ipairs(scripts) do\n    if not grouped[script.category] then\n      grouped[script.category] = {}\n    end\n    table.insert(grouped[script.category], script)\n  end\n  \n  return grouped, nil\nend\n\n---Check if package.json exists in the given directory or parents\n---@param cwd string|nil Directory to check (defaults to current working directory)\n---@return boolean has_package_json\nfunction M.has_package_json(cwd)\n  cwd = cwd or vim.fn.getcwd()\n  local package_path, _ = find_package_json(cwd)\n  return package_path ~= nil\nend\n\n---Get the path to the nearest package.json file\n---@param cwd string|nil Directory to start search from\n---@return string|nil package_json_path\nfunction M.get_package_json_path(cwd)\n  cwd = cwd or vim.fn.getcwd()\n  local package_path, _ = find_package_json(cwd)\n  return package_path\nend\n\nreturn M\n
